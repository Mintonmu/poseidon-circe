// 这个文件是 Circe 服务器应用程序框架的一部分。
// Copyleft 2017 - 2018, LH_Mouse. All wrongs reserved.

#include "precompiled.hpp"
#include "user_defined_functions.hpp"
#include "protocol/utilities.hpp"

#include "protocol/messages_foyer.hpp"
#include "singletons/box_acceptor.hpp"

namespace Circe {
namespace Box {

void UserDefinedFunctions::handle_http_request(
	// Output parameters
	Poseidon::Http::StatusCode &resp_status_code,  // This status code is sent to the client intactly.
	Poseidon::OptionalMap &resp_headers,           // These HTTP headers are sent to the client.
	                                               // The 'Content-Length', 'Connection' and 'Access-Control-*' headers are set by the gate server and shall not be specified here.
	                                               // The gate server compresses HTTP responses as needed. Setting 'Content-Encoding' to 'identity' explicitly suppresses HTTP compression.
	Poseidon::StreamBuffer &resp_entity,           // These data are sent to the client as the response entity.
	// Input parameters
	Poseidon::Uuid client_uuid,                    // This is the UUID of the client connection generated by the gate server.
	std::string client_ip,                         // This is the IP address of the client from the gate server's point of view.
	std::string auth_token,                        // This is the authentication token for this client returned by the auth server.
	Poseidon::Http::Verb verb,                     // This is the verb sent by the client.
	std::string decoded_uri,                       // This is the request URI sent by the client. GET parameters have been stripped.
	Poseidon::OptionalMap params,                  // These are GET parameters sent by the client (as part of the URI).
	Poseidon::OptionalMap req_headers,             // These are HTTP headers sent by the client.
	Poseidon::StreamBuffer req_entity)             // This is the request entity sent by the client.
{
	PROFILE_ME;

	LOG_CIRCE_FATAL("TODO: Handle HTTP request: ", Poseidon::Http::get_string_from_verb(verb), " ", decoded_uri, "\n", params, "\n", req_entity);

	if(decoded_uri == "/favicon.ico"){
		resp_status_code = 404;
		return;
	}

	resp_status_code = 200;
	resp_headers.set(Poseidon::sslit("Content-Type"), "text/html");
	resp_entity.put("<html>");
	resp_entity.put("  <head>");
	resp_entity.put("    <title>Hello World!</title>");
	resp_entity.put("  </head>");
	resp_entity.put("  <body>");
	resp_entity.put("    <h1>Hello World!</h1>");
	resp_entity.put("  </body>");
	resp_entity.put("</html>");
}

void UserDefinedFunctions::handle_websocket_establishment(
	const boost::shared_ptr<WebSocketShadowSession> &client_session,  // This is the session cast by the WebSocket connection on the gate server.
	std::string decoded_uri,                                          // This is the request URI sent by the client. GET parameters have been stripped.
	Poseidon::OptionalMap params)                                     // These are GET parameters sent by the client (as part of the URI).
{
	PROFILE_ME;

	LOG_CIRCE_FATAL("TODO: Handle WebSocket establishment: ", decoded_uri, "\n", params);
}

void UserDefinedFunctions::handle_websocket_message(
	const boost::shared_ptr<WebSocketShadowSession> &client_session,  // This is the session cast by the WebSocket connection on the gate server.
	Poseidon::WebSocket::OpCode opcode,                               // This is the opcode sent by the client. This may be `Poseidon::WebSocket::OP_DATA_TEXT` or `Poseidon::WebSocket::OP_DATA_BINARY`.
	Poseidon::StreamBuffer payload)                                   // This is the payload sent by the client. If the opcode claims a text message, the payload will be a valid UTF-8 string.
{
	PROFILE_ME;

	LOG_CIRCE_FATAL("TODO: Handle WebSocket message: ", opcode, ": ", payload);

//	for(unsigned i = 0; i < 3; ++i){
//		char str[100];
//		std::sprintf(str, "hello %d", i);
//		client_session->send(Poseidon::WebSocket::OP_DATA_TEXT, Poseidon::StreamBuffer(str));
//	}
	Protocol::Foyer::WebSocketPackedBroadcastNotificationToGate ntfy;
	for(unsigned i = 0; i < 3; ++i){
		ntfy.clients.emplace_back();
		ntfy.clients.back().gate_uuid = client_session->get_gate_uuid();;
		ntfy.clients.back().client_uuid = client_session->get_client_uuid();
	}
	for(unsigned i = 0; i < 3; ++i){
		char str[100];
		std::sprintf(str, "hello %d", i);
		AUTO(it, Protocol::emplace_at_end(ntfy.messages));
		it->opcode = Poseidon::WebSocket::OP_DATA_TEXT;
		it->payload = Poseidon::StreamBuffer(str);
	}
	BoxAcceptor::safe_broadcast_notification(ntfy);
}

void UserDefinedFunctions::handle_websocket_closure(
	const boost::shared_ptr<WebSocketShadowSession> &client_session,  // This is the session cast by the WebSocket connection on the gate server.
	Poseidon::WebSocket::StatusCode status_code,                      // This is the status code in the closure frame received from the client, or `Poseidon::WebSocket::ST_RESERVED_ABNORMAL` if no closure frame was received.
	const char *reason)                                               // This is the payload in the closure frame received from the client, or an unspecified string if no closure frame was received.
{
	PROFILE_ME;

	LOG_CIRCE_FATAL("TODO: Handle WebSocket closure: ", status_code, ": ", reason);
}

}
}
